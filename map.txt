// --- Replace your helper/comparator block with this ---

type LatLngLike = google.maps.LatLng | google.maps.LatLngLiteral;

const hasGoogleMaps = (): boolean =>
  typeof window !== "undefined" && !!(window as any).google?.maps?.LatLng;

const isLatLngInstance = (v: unknown): v is google.maps.LatLng =>
  hasGoogleMaps() && v instanceof (google.maps.LatLng as any);

const isLatLngLiteral = (v: unknown): v is google.maps.LatLngLiteral =>
  !!v &&
  typeof (v as any).lat === "number" &&
  typeof (v as any).lng === "number";

/** Safe equality for LatLng values with or without the Maps runtime loaded */
const latLngEquals = (a: LatLngLike, b: LatLngLike): boolean => {
  const mapsReady = hasGoogleMaps();

  // If both are literals, compare numerically (works even when Maps isn't loaded)
  if (isLatLngLiteral(a) && isLatLngLiteral(b)) {
    return a.lat === b.lat && a.lng === b.lng;
  }

  // If Maps is available, normalize both sides to LatLng and use .equals()
  if (mapsReady) {
    const aa = isLatLngInstance(a) ? a : new google.maps.LatLng(a);
    const bb = isLatLngInstance(b) ? b : new google.maps.LatLng(b);
    return aa.equals(bb);
  }

  // Maps not loaded and at least one side isn't a pure literal â†’ treat as different
  return false;
};

const deepCompareEqualsForMaps = createCustomEqual({
  createIsNestedEqual:
    (deepEqual) =>
    (a: unknown, b: unknown): boolean => {
      const aIsLL = isLatLngInstance(a) || isLatLngLiteral(a);
      const bIsLL = isLatLngInstance(b) || isLatLngLiteral(b);

      if (aIsLL && bIsLL) {
        return latLngEquals(a as LatLngLike, b as LatLngLike);
      }

      return deepEqual(a, b);
    },
});


----------------------------------------------------------

// v4-style, with type cast to any
const deepCompareEqualsForMaps = createCustomEqual(
  ((deepEqual: (a: unknown, b: unknown) => boolean) =>
    (a: unknown, b: unknown): boolean => {
      const aIsLL =
        a instanceof google.maps.LatLng ||
        (!!a && typeof (a as any).lat === "number" && typeof (a as any).lng === "number");
      const bIsLL =
        b instanceof google.maps.LatLng ||
        (!!b && typeof (b as any).lat === "number" && typeof (b as any).lng === "number");

      if (aIsLL && bIsLL) {
        const aa = a instanceof google.maps.LatLng ? a : new google.maps.LatLng(a);
        const bb = b instanceof google.maps.LatLng ? b : new google.maps.LatLng(b);
        return aa.equals(bb);
      }

      return deepEqual(a, b);
    }) as any // ðŸ‘ˆ cast to bypass TS in v4
);
------------------------------------------------------------------
import React, { useEffect, useMemo, useRef, useState } from "react";

export default function EquipmentMap(props: {
  center?: { lat: number; lng: number };
  zoom?: number;
  options?: google.maps.MapOptions;
}) {
  const [map, setMap] = useState<google.maps.Map | null>(null);

  const defaultLat = 40.73061;
  const defaultLng = -73.935242;
  const defaultZoom = 12;

  // Extract primitive values
  const centerLat = props.center?.lat ?? defaultLat;
  const centerLng = props.center?.lng ?? defaultLng;
  const zoomValue = props.zoom ?? defaultZoom;

  // Memoize map options
  const mapOptions = useMemo<google.maps.MapOptions>(
    () => ({
      ...props.options,
      center: { lat: centerLat, lng: centerLng },
      zoom: zoomValue,
    }),
    [centerLat, centerLng, zoomValue, props.options]
  );

  // Apply options when map or options change
  useEffect(() => {
    if (map) {
      map.setOptions(mapOptions);
    }
  }, [map, mapOptions]);

  return <div id="map" style={{ height: "100%", width: "100%" }} />;
}


-------------------------------------------------------------

// keep your helpers as-is above: hasGoogleMaps, isLatLngInstance, isLatLngLiteral, latLngEquals

const deepCompareEqualsForMaps = createCustomEqual({
  // v5 API: customize the built-in object comparator
  createCustomConfig: (defaultConfig) => ({
    areObjectsEqual(a, b, state) {
      const aIsLL = isLatLngInstance(a) || isLatLngLiteral(a);
      const bIsLL = isLatLngInstance(b) || isLatLngLiteral(b);
      if (aIsLL && bIsLL) {
        return latLngEquals(a as LatLngLike, b as LatLngLike);
      }
      // fallback to the library's default object equality
      return defaultConfig.areObjectsEqual(a, b, state);
    },
  }),
});
